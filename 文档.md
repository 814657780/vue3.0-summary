# 主要是记录vue3相关的技术文档

# API
## 组合式API
### 响应式：核心

#### ref()
```
响应式 API：核心

# ref()
接受一个内部值，返回一个响应式的、可更改的ref对象，此对象只有一个指向其内部值的属性 .value

类型
function ref<T>(value:T):Ref<UnwrapRef<T>>

interface Ref<T> {
    value: T
}

详细信息
ref对象是可更改的，也就是说你可以为.value赋予新的值。它也是响应式的，即所有对.value的操作都将被追踪，
并且写操作会触发与之相关的副作用。
如果将一个对象赋值给ref，那么这个对象将通过reactive()转为具有更深层次响应式的对象。
这也意味着如果对象中包含了嵌套的ref，它们将被深层地解包。

若要避免这种深层次的转换，请使用shallowRef()来替代。

示例
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

# 用ref()定义响应式变量
reactive()的种种限制归根结底是因为JavaScript没有可以作用于所有类型的“引用”机制。
为此，Vue提供了一个ref()方法允许我们创建可以使用任何值类型的响应式ref：
import { ref } from 'vue'

const count =  ref(0)
ref()将传入参数的值包装为一个带.value属性的ref对象

const count = ref(0)
console.log(count) // { value:0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

和响应式对象的属性类似，ref的.value属性也是响应式的。同时，当值为对象类型时，会用
reactive()自动转换它的.value。

一个包含对象类型值的ref可以响应式地替换整个对象：
const objectRef = ref({count:0})
// 这是响应式的替换
objectRef.value = { count:1 }

ref被传递给函数或是从一般对象上被解构时，不会丢失响应性：
const obj = {
    foo:ref(1),
    bar:ref(2)
}
// 该函数接收一个ref
// 需要通过.value取值
// 但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj

简言之，ref()让我们能创造一种对任意值的“引用”，并能够在不丢失响应性的前提下
传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到组合函数中。

# ref在模板中的解包
当ref在模板中作为顶层的属性被访问时，它们会被自动“解包”，所以不需要使用.value。
下面是之前的计数器例子，用ref() 代替：

<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
    count.value++
}
</script>
<template>
  <button @click="increment">
    {{ count }}  <!-- 无需 .value -->
  </button>
</template>

请注意，仅当ref是模板渲染上下文的顶层属性时才适用自动”解包“。例如，foo是顶层属性，
但object.foo不是。

所以我们给出以下object：
const object = { foo:ref(1) }
下面的表达式将不会像预期的那样工作：
{{ object.foo + 1 }}
渲染的结果会是一个[object Object],因为object.foo是一个ref对象。我们可以通过
将foo改成顶层属性来解决这个问题：
const { foo } = object
{{ foo + 1 }}
现在渲染结果将是2。
需要注意的是，如果一个ref是文本插值（即一个{{}}符号）计算的最终值，它也将被解包。
因此下面的渲染结果将为1：
{{ object.foo }}
这只是文本插值的一个方便功能，相当于{{ object.foo.value }}。

# ref在响应式对象中的解包
当一个ref被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此表现
得和一般的属性一样：
const count = ref(0)
const state = reactive({
    count
})
console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1

如果将一个新的ref赋值给一个关联了已有ref的属性，那么它会替换掉旧的ref：

const otherCount = ref(2)
state.count = otherCount
console.log(state.count) // 2
// 原始ref现在已经和state.count 失去联系
console.log(count.value) // 1

只有当嵌套在一个深层响应式对象内时，才会发生ref解包。当其作为浅层响应式对象的
属性被访问时不会解包。

# 数组和集合类型的ref解包
跟响应式对象不同，当ref作为响应式数组或像Map这种原生集合类型的元素被访问时，
不会进行解包。

const books = reactive([ref('Vue 3 Guide')])
// 这里需要.value
console.log(books[0].value)

const map = reactive(new Map([['count',ref(0)]]))
// 这里需要.value
console.log(map.get('count').value)

# 响应式语法糖

相对于普通的JavaScript变量，我们不得不用相对繁琐的.value来获取ref的值。
这是一个受限于JavaScript语言限制的缺点。然而，通过编译时转换，我们可以让
编译器帮我们省去使用.value的麻烦。Vue提供了一种编译时转换，使得我们可以像这样
书写之前的”计数器“示例：
<script setup>
let count = $ref(0)

function increment() {
    // 无需.value
    count++
}
</script>

<template>
  <button @click="increment"></button>
</template>

# 为 ref() 标注类型（TS）

ref会根据初始化时的值推导其类型：
import { ref } from 'vue'

// 推导出的类型：Ref<number>
const year = ref(2020)
// => TS Error：Type ‘string’ is not assignable to type 'number',
year.value = '2020'

有时我们可能想为ref内的值指定一个更复杂的类型，可以通过使用Ref这个类型：
import { ref } from 'vue'
import type { Ref } from 'vue'

const year:Ref<string | number> = ref('2020')

year.value = 2020 // 成功！

或者，在调用ref() 时传入一个泛型参数，来覆盖默认的推导行为：
// 得到的类型：Ref<string | number>
const year = ref<string | number>('2020')
year.value = 2020 // 成功！

如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含
undefined的联合类型：
// 推导得到的类型：Ref<number | undefined>
const n = ref<number>()
```
#### reactive()
```
返回一个对象的响应式代理。
.类型
function reactive<T extends object>(target:T):UnwrapNestedRefs<T>
.详细信息
响应式转换是‘深层’的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包
任何ref属性，同时保持响应性。

值得注意的是，当访问到某个响应式数组或Map这样的原生集合类型中的ref元素时，
不会执行ref的解包。

若要避免深层响应式转换，只想保留这个对象顶层次访问的响应性，请使用
shallowReactive()作替代。

返回的对象以及其中嵌套的对象都会通过ES Proxy包裹，因此不等于源对象，建议
只使用响应式代理，避免使用原始对象。

.示例
创建一个响应式对象：
const obj = reactive({count:0})
obj.count++

ref的解包：
const count = ref(1)
const obj = reactive({count})

// ref会解包
console.log(obj.count === count.value) // true

// 会更新‘obj.count’
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2

// 也会更新 ‘count’ ref
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3

注意当访问到某个响应式数组或Map这样的原生集合类型中的ref元素时，不会执行
ref的解包：
const books = reactive([ref('Vue 3 Guide')])
// 这里需要.value
console.log(books[0].value)

const map = reactive(new Map([['count',ref(0)]]))
// 这里需要.value
console.log(map.get('count').value)

将一个ref赋值给为一个reactive属性时，该ref会被自动解包：
const count = ref(1)
const obj = reactive({})
obj.count = count
console.log(obj.count) // 1
console.log(obj.count === count.value) // true

# 声明响应式状态

我们可以使用reactive()函数创建一个响应式对象或者数组：
import { reactive } from 'vue'
const state = reactive({ count:0 })

响应式对象其实是JavaScript Proxy，其行为表现与一般对象相似。
不同之处在于Vue能够跟踪对响应式对象属性的访问与更改操作。
如果你对这其中的细节感到好奇，我们在深入响应式系统一章中会进行解释。

要在组件模板中使用响应式状态，需要在setup()函数中定义并返回。

import  { reactive } from 'vue'

export default {
    // 'setup'是一个专门用于组合式API的特殊钩子函数
    setup(){
        const state = reactive({count:0})

        // 暴露state到模板
        return {
            state
        }
    }
}

<div>{{ state.count }}</div>

自然，我们也可以在同一作用域下定义一个更新state的函数，并作为一个方法与
state一起暴露出去：

import { reactive } from 'vue'

export default {
    setup(){
        const state = reactive({count:0})
        function increment(){
            state.count++
        }
        // 不要忘记同时暴露 increment 函数

        return {
            state,
            increment
        }
    }
}

暴露的方法通常会被用作事件监听器：
<button @click="increment">
{{state.count}}
</button>

# <script setup>
在setup()函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过
使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用
<script setup>来大幅度地简化代码。

<script setup>
import { reactive } from 'vue'
const state = reactive({count:0})

function increment() {
    state.count++
}
</script>
<template>
<button @click="increment">
{{state.count}}
</button>
</template>

<script setup>中的顶层的导入和变量声明可在同一个组件的模板中直接使用。
你可以理解为模板中的表达式和<script setup>中的代码处在同一个作用域中。

# DOM更新时机
当你更改响应式状态后，DOM会自动更新。然而，你得注意DOM的更新并不是同步的。
相反，Vue将缓冲它们直到更新周期的“下个时机”以确保无论你进行了多少次状态更改，
每个组件都只需要更新一次。

若要等待一个状态改变后的DOM更新完成，你可以使用nextTick()这个全局API：
import { nextTick } from 'vue'
function increment() {
    state.count ++
    nextTick(()=>{
        // 访问更新后的DOM
    })
}

# 深层响应性
在Vue中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，
你的改动也能被检测到。
import { reactive } from 'vue'
const obj = reactive({
    nested:{count:0},
    arr: ['foo','bar']
})
function mutatDeeply() {
    // 以下都会按照期望工作
    obj.nested.count++;
    obj.arr.push('baz')
}

# 响应式代理 vs 原始对象
值得注意的是，reactive() 返回的是一个原始对象的Proxy，它和原始对象
是不相等的：
const raw = {}
const proxy = reactive(raw)

// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false

只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用Vue的响应式系统
的最佳实践是仅使用你声明对象的代理版本。

为保证访问代理的一致性，对同一个原始对象调用reactive()会总是返回同样的代理对象，
而对一个已存在的代理对象调用reactive()会返回其本身：
// 在同一个对象上调用reactive()会返回相同的代理
console.log( reactive(raw) === proxy) // true

// 在一个代理上调用reactive() 会返回它自己
console.log( reactive(proxy) === proxy ) // true

这个规则对嵌套对象也使用。依靠深层响应式性，响应式对象内的嵌套对象依然是代理：
const proxy = reactive({})
const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false

# reactive()的局限性
reactive() API 有两条限制：

1. 仅对对象类型有效（对象、数组和Map、Set这样的集合类型），而对string、
number和boolean这样的原始类型无效。

2. 因为Vue的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象
的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的
响应性连接丢失：
let state = reactive({count:0})
// 上面的引用({count:0})将不再被追踪（响应性连接已丢失）
state = reactive({count:1})

同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数
时，我们会失去响应性；
const state = reactive({count:0})
// n是一个局部变量，同state.count
// 失去响应性连接
let n = state.count
// 不影响原始的state
n++

// count也和state.count失去了响应性连接
let { count } = state
// 不会影响原始的state
count++

// 该函数接收一个普通数字，并且
// 将无法跟踪state.count 的变化
callSomeFunction(state.count)
```
#### readonly()
```
接受一个对象（不论是响应式还是普通的）或是一个ref，返回一个愿值的只读代理。
.类型
function readonly<T extends object>(
    target:T
):DeepReadonly<UnwrapNestedRefs<T>>
.详细信息
只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的ref解包行为与
reactive()相同，但解包得到的值都是只读的。
要避免深层级的转换行为，请使用shallowReadonly()作替代。

.示例
const original = reactive({ count:0 })
const copy = readonly(original)

watchEffect(()=>{
    // 用来做响应性追踪
    console.log(copy.count)
})
// 更改源属性会触发其依赖的侦听器
original.count++
// 更改该只读副本将会失败，并得到一个警告
copy.count++ // warning!
```
#### watchEffect()
```
立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行；

.类型
function watchEffect(
    effect:(onCleanup:OnCleanup) => void,
    options?:WatchEffectOptions
):StopHandle
type OnCleanup = (CleanupFn:()=>void)=>void

interface WatchEffectOptions {
    flush?:'pre'|'post'|'sync' // 默认： ‘pre’
    onTrack?:(event:DebuggerEvent)=>void
    onTrigger?:(event:DebuggerEvent)=>void
}

type StopHandle = ()=> void

.详细信息
第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回
调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的
异步请求（参见下面的示例）
第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。

默认情况下，侦听器将在组件渲染之前执行。设置flush:'post'将会使侦听器延迟到组件渲染
之后再执行。详见回调的触发时机。在某些特殊情况下（例如要使缓存失效），可能有必要在响应式
依赖发生变化时立即触发侦听器。这可以通过设置flush:'sync'来实现。然而，该设置应谨慎使用，
因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。

返回值是一个用来停止该副作用的函数。

.示例
const count = ref(0)
watchEffect(()=>cconsole.log(count.value))
// -> 输出 0
count.value++
// -> 输出 1

副作用清除：
watchEffect(async (onCleanup)=>{
    const { response,cancel } = doAsyncWork(id.value)
    // 'cancel' 会在 ‘id’ 更改时调用
    // 以便取消之前
    // 未完成的请求
    onCleanup(cancel)
    data.value = await response
})

停止侦听器
const stop = watchEffect(()=>{})
<!-- 当不再需要此侦听器时 -->
stop()

选项：
watchEffect(()=>{},{
    flush: 'post',
    onTrack(e){
      debugger
    },
    onTrigger(e){
      debugger  
    }
})
```
#### watchPostEffect()
```
watchEffect() 使用 flush: 'post' 选项时的别名。
```
#### watchSyncEffect()
```
watchEffect() 使用 flush: 'sync' 选项时的别名。
```
#### watch()
```
侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。
.类型
// 侦听单个来源
function watch<T>(
    source:WatchSource<T>,
    callback: WatchCallback<T>,
    options?: WatchOptions
): StopHandle

// 侦听多个来源
function watch<T>(
  sources: WatchSource<T>[],
  callback: WatchCallback<T[]>,
  options?: WatchOptions
): StopHandle

type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void

type WatchSource<T> =
  | Ref<T> // ref
  | (() => T) // getter
  | T extends object
  ? T
  : never // 响应式对象

interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean // 默认：false
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}

为了便于阅读，对类型进行了简化。

.详细信息
watch()默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。
第一个参数是侦听器源。这个来源可以是以下几种：
一个函数，返回一个值
一个ref
一个响应式对象
... 或是有以上类型的值组成的数组

第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及
一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。

当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。
第三个可选的参数是一个对象，支持以下这些选项：
. immediate: 在侦听器创建时立即触发回调。第一次调用时，旧值将为undefined。
. deep: 如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。
. flush: 调整回调的刷新时机。
. onTrack/onTrigger: 调试侦听器的依赖关系。
声明侦听器回调时避免使用箭头函数，因为它们将无法通过this访问组件实例。
. 示例
export default {
    data(){
        return {
            a:1,
            b:2,
            c:{
                d:4
            },
            e:5,
            f:6
        }
    },
    watch: {
        // 侦听根级属性
        a(val,oldVal){
          console.log(`new: ${val},old:${oldVal}`)
        },
        // 字符串方法名称
        b: 'someMethod',
        // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深
        c:{
            handler(val,oldVal){
                console.log('c changed')
            },
            deep:true
        },
        // 侦听单个嵌套属性：
        'c.d':function(val,oldVal){
            // do something
        },
        // 该回调将会在侦听开始之后立即调用
        e:{
            handler(val,oldVal){
                console.log('e changed')
            },
            immediate:true
        },
        // 你可以传入回调数组，它们将会被逐一调用
        f:[
          'handle1',
          function handle2(val,oldVal){
            console.log('handle2 triggered')
          },
          {
              handler:function handle3(val,oldVal){
                  console.log('handle3 triggered')
              }
          }
        ]
    },
    methods:{
        someMethod(){
          console.log('b changed')
        },
        handle1() {
            console.log('handle1 triggered')
        }
    },
    created(){
        this.a = 3 // => new: 3, old: 1
    }
}
```
#### emits
```
用于声明由组件触发的自定义事件。
```