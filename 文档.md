# 主要是记录vue3相关的技术文档

# API
## 组合式API
### 响应式：核心
```
响应式 API：核心

# ref()
接受一个内部值，返回一个响应式的、可更改的ref对象，此对象只有一个指向其内部值的属性 .value

类型
function ref<T>(value:T):Ref<UnwrapRef<T>>

interface Ref<T> {
    value: T
}

详细信息
ref对象是可更改的，也就是说你可以为.value赋予新的值。它也是响应式的，即所有对.value的操作都将被追踪，
并且写操作会触发与之相关的副作用。
如果将一个对象赋值给ref，那么这个对象将通过reactive()转为具有更深层次响应式的对象。
这也意味着如果对象中包含了嵌套的ref，它们将被深层地解包。

若要避免这种深层次的转换，请使用shallowRef()来替代。

示例
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

# 用ref()定义响应式变量
reactive()的种种限制归根结底是因为JavaScript没有可以作用于所有类型的“引用”机制。
为此，Vue提供了一个ref()方法允许我们创建可以使用任何值类型的响应式ref：
import { ref } from 'vue'

const count =  ref(0)
ref()将传入参数的值包装为一个带.value属性的ref对象

const count = ref(0)
console.log(count) // { value:0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

和响应式对象的属性类似，ref的.value属性也是响应式的。同时，当值为对象类型时，会用
reactive()自动转换它的.value。

一个包含对象类型值的ref可以响应式地替换整个对象：
const objectRef = ref({count:0})
// 这是响应式的替换
objectRef.value = { count:1 }

ref被传递给函数或是从一般对象上被解构时，不会丢失响应性：
const obj = {
    foo:ref(1),
    bar:ref(2)
}
// 该函数接收一个ref
// 需要通过.value取值
// 但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj

简言之，ref()让我们能创造一种对任意值的“引用”，并能够在不丢失响应性的前提下
传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到组合函数中。

# ref在模板中的解包
当ref在模板中作为顶层的属性被访问时，它们会被自动“解包”，所以不需要使用.value。
下面是之前的计数器例子，用ref() 代替：

<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
    count.value++
}
</script>
```
