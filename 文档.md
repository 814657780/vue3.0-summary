# 主要是记录vue3相关的技术文档

# API
## 组合式API
### 响应式：核心

#### ref()
```
响应式 API：核心

# ref()
接受一个内部值，返回一个响应式的、可更改的ref对象，此对象只有一个指向其内部值的属性 .value

类型
function ref<T>(value:T):Ref<UnwrapRef<T>>

interface Ref<T> {
    value: T
}

详细信息
ref对象是可更改的，也就是说你可以为.value赋予新的值。它也是响应式的，即所有对.value的操作都将被追踪，
并且写操作会触发与之相关的副作用。
如果将一个对象赋值给ref，那么这个对象将通过reactive()转为具有更深层次响应式的对象。
这也意味着如果对象中包含了嵌套的ref，它们将被深层地解包。

若要避免这种深层次的转换，请使用shallowRef()来替代。

示例
const count = ref(0)
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

# 用ref()定义响应式变量
reactive()的种种限制归根结底是因为JavaScript没有可以作用于所有类型的“引用”机制。
为此，Vue提供了一个ref()方法允许我们创建可以使用任何值类型的响应式ref：
import { ref } from 'vue'

const count =  ref(0)
ref()将传入参数的值包装为一个带.value属性的ref对象

const count = ref(0)
console.log(count) // { value:0 }
console.log(count.value) // 0

count.value++
console.log(count.value) // 1

和响应式对象的属性类似，ref的.value属性也是响应式的。同时，当值为对象类型时，会用
reactive()自动转换它的.value。

一个包含对象类型值的ref可以响应式地替换整个对象：
const objectRef = ref({count:0})
// 这是响应式的替换
objectRef.value = { count:1 }

ref被传递给函数或是从一般对象上被解构时，不会丢失响应性：
const obj = {
    foo:ref(1),
    bar:ref(2)
}
// 该函数接收一个ref
// 需要通过.value取值
// 但它会保持响应性
callSomeFunction(obj.foo)

// 仍然是响应式的
const { foo, bar } = obj

简言之，ref()让我们能创造一种对任意值的“引用”，并能够在不丢失响应性的前提下
传递这些引用。这个功能很重要，因为它经常用于将逻辑提取到组合函数中。

# ref在模板中的解包
当ref在模板中作为顶层的属性被访问时，它们会被自动“解包”，所以不需要使用.value。
下面是之前的计数器例子，用ref() 代替：

<script setup>
import { ref } from 'vue'
const count = ref(0)
function increment() {
    count.value++
}
</script>
<template>
  <button @click="increment">
    {{ count }}  <!-- 无需 .value -->
  </button>
</template>

请注意，仅当ref是模板渲染上下文的顶层属性时才适用自动”解包“。例如，foo是顶层属性，
但object.foo不是。

所以我们给出以下object：
const object = { foo:ref(1) }
下面的表达式将不会像预期的那样工作：
{{ object.foo + 1 }}
渲染的结果会是一个[object Object],因为object.foo是一个ref对象。我们可以通过
将foo改成顶层属性来解决这个问题：
const { foo } = object
{{ foo + 1 }}
现在渲染结果将是2。
需要注意的是，如果一个ref是文本插值（即一个{{}}符号）计算的最终值，它也将被解包。
因此下面的渲染结果将为1：
{{ object.foo }}
这只是文本插值的一个方便功能，相当于{{ object.foo.value }}。

# ref在响应式对象中的解包
当一个ref被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此表现
得和一般的属性一样：
const count = ref(0)
const state = reactive({
    count
})
console.log(state.count) // 0

state.count = 1
console.log(count.value) // 1

如果将一个新的ref赋值给一个关联了已有ref的属性，那么它会替换掉旧的ref：

const otherCount = ref(2)
state.count = otherCount
console.log(state.count) // 2
// 原始ref现在已经和state.count 失去联系
console.log(count.value) // 1

只有当嵌套在一个深层响应式对象内时，才会发生ref解包。当其作为浅层响应式对象的
属性被访问时不会解包。

# 数组和集合类型的ref解包
跟响应式对象不同，当ref作为响应式数组或像Map这种原生集合类型的元素被访问时，
不会进行解包。

const books = reactive([ref('Vue 3 Guide')])
// 这里需要.value
console.log(books[0].value)

const map = reactive(new Map([['count',ref(0)]]))
// 这里需要.value
console.log(map.get('count').value)

# 响应式语法糖

相对于普通的JavaScript变量，我们不得不用相对繁琐的.value来获取ref的值。
这是一个受限于JavaScript语言限制的缺点。然而，通过编译时转换，我们可以让
编译器帮我们省去使用.value的麻烦。Vue提供了一种编译时转换，使得我们可以像这样
书写之前的”计数器“示例：
<script setup>
let count = $ref(0)

function increment() {
    // 无需.value
    count++
}
</script>

<template>
  <button @click="increment"></button>
</template>

# 为 ref() 标注类型（TS）

ref会根据初始化时的值推导其类型：
import { ref } from 'vue'

// 推导出的类型：Ref<number>
const year = ref(2020)
// => TS Error：Type ‘string’ is not assignable to type 'number',
year.value = '2020'

有时我们可能想为ref内的值指定一个更复杂的类型，可以通过使用Ref这个类型：
import { ref } from 'vue'
import type { Ref } from 'vue'

const year:Ref<string | number> = ref('2020')

year.value = 2020 // 成功！

或者，在调用ref() 时传入一个泛型参数，来覆盖默认的推导行为：
// 得到的类型：Ref<string | number>
const year = ref<string | number>('2020')
year.value = 2020 // 成功！

如果你指定了一个泛型参数但没有给出初始值，那么最后得到的就将是一个包含
undefined的联合类型：
// 推导得到的类型：Ref<number | undefined>
const n = ref<number>()
```
#### reactive()
```
返回一个对象的响应式代理。
.类型
function reactive<T extends object>(target:T):UnwrapNestedRefs<T>
.详细信息
响应式转换是‘深层’的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包
任何ref属性，同时保持响应性。

值得注意的是，当访问到某个响应式数组或Map这样的原生集合类型中的ref元素时，
不会执行ref的解包。

若要避免深层响应式转换，只想保留这个对象顶层次访问的响应性，请使用
shallowReactive()作替代。

返回的对象以及其中嵌套的对象都会通过ES Proxy包裹，因此不等于源对象，建议
只使用响应式代理，避免使用原始对象。

.示例
创建一个响应式对象：
const obj = reactive({count:0})
obj.count++

ref的解包：
const count = ref(1)
const obj = reactive({count})

// ref会解包
console.log(obj.count === count.value) // true

// 会更新‘obj.count’
count.value++
console.log(count.value) // 2
console.log(obj.count) // 2

// 也会更新 ‘count’ ref
obj.count++
console.log(obj.count) // 3
console.log(count.value) // 3

注意当访问到某个响应式数组或Map这样的原生集合类型中的ref元素时，不会执行
ref的解包：
const books = reactive([ref('Vue 3 Guide')])
// 这里需要.value
console.log(books[0].value)

const map = reactive(new Map([['count',ref(0)]]))
// 这里需要.value
console.log(map.get('count').value)

将一个ref赋值给为一个reactive属性时，该ref会被自动解包：
const count = ref(1)
const obj = reactive({})
obj.count = count
console.log(obj.count) // 1
console.log(obj.count === count.value) // true

# 声明响应式状态

我们可以使用reactive()函数创建一个响应式对象或者数组：
import { reactive } from 'vue'
const state = reactive({ count:0 })

响应式对象其实是JavaScript Proxy，其行为表现与一般对象相似。
不同之处在于Vue能够跟踪对响应式对象属性的访问与更改操作。
如果你对这其中的细节感到好奇，我们在深入响应式系统一章中会进行解释。

要在组件模板中使用响应式状态，需要在setup()函数中定义并返回。

import  { reactive } from 'vue'

export default {
    // 'setup'是一个专门用于组合式API的特殊钩子函数
    setup(){
        const state = reactive({count:0})

        // 暴露state到模板
        return {
            state
        }
    }
}

<div>{{ state.count }}</div>

自然，我们也可以在同一作用域下定义一个更新state的函数，并作为一个方法与
state一起暴露出去：

import { reactive } from 'vue'

export default {
    setup(){
        const state = reactive({count:0})
        function increment(){
            state.count++
        }
        // 不要忘记同时暴露 increment 函数

        return {
            state,
            increment
        }
    }
}

暴露的方法通常会被用作事件监听器：
<button @click="increment">
{{state.count}}
</button>

# <script setup>
在setup()函数中手动暴露大量的状态和方法非常繁琐。幸运的是，我们可以通过
使用构建工具来简化该操作。当使用单文件组件（SFC）时，我们可以使用
<script setup>来大幅度地简化代码。

<script setup>
import { reactive } from 'vue'
const state = reactive({count:0})

function increment() {
    state.count++
}
</script>
<template>
<button @click="increment">
{{state.count}}
</button>
</template>

<script setup>中的顶层的导入和变量声明可在同一个组件的模板中直接使用。
你可以理解为模板中的表达式和<script setup>中的代码处在同一个作用域中。

# DOM更新时机
当你更改响应式状态后，DOM会自动更新。然而，你得注意DOM的更新并不是同步的。
相反，Vue将缓冲它们直到更新周期的“下个时机”以确保无论你进行了多少次状态更改，
每个组件都只需要更新一次。

若要等待一个状态改变后的DOM更新完成，你可以使用nextTick()这个全局API：
import { nextTick } from 'vue'
function increment() {
    state.count ++
    nextTick(()=>{
        // 访问更新后的DOM
    })
}

# 深层响应性
在Vue中，状态都是默认深层响应式的。这意味着即使在更改深层次的对象或数组，
你的改动也能被检测到。
import { reactive } from 'vue'
const obj = reactive({
    nested:{count:0},
    arr: ['foo','bar']
})
function mutatDeeply() {
    // 以下都会按照期望工作
    obj.nested.count++;
    obj.arr.push('baz')
}

# 响应式代理 vs 原始对象
值得注意的是，reactive() 返回的是一个原始对象的Proxy，它和原始对象
是不相等的：
const raw = {}
const proxy = reactive(raw)

// 代理对象和原始对象不是全等的
console.log(proxy === raw) // false

只有代理对象是响应式的，更改原始对象不会触发更新。因此，使用Vue的响应式系统
的最佳实践是仅使用你声明对象的代理版本。

为保证访问代理的一致性，对同一个原始对象调用reactive()会总是返回同样的代理对象，
而对一个已存在的代理对象调用reactive()会返回其本身：
// 在同一个对象上调用reactive()会返回相同的代理
console.log( reactive(raw) === proxy) // true

// 在一个代理上调用reactive() 会返回它自己
console.log( reactive(proxy) === proxy ) // true

这个规则对嵌套对象也使用。依靠深层响应式性，响应式对象内的嵌套对象依然是代理：
const proxy = reactive({})
const raw = {}
proxy.nested = raw

console.log(proxy.nested === raw) // false

# reactive()的局限性
reactive() API 有两条限制：

1. 仅对对象类型有效（对象、数组和Map、Set这样的集合类型），而对string、
number和boolean这样的原始类型无效。

2. 因为Vue的响应式系统是通过属性访问进行追踪的，因此我们必须始终保持对该响应式对象
的相同引用。这意味着我们不可以随意地“替换”一个响应式对象，因为这将导致对初始引用的
响应性连接丢失：
let state = reactive({count:0})
// 上面的引用({count:0})将不再被追踪（响应性连接已丢失）
state = reactive({count:1})

同时这也意味着当我们将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数
时，我们会失去响应性；
const state = reactive({count:0})
// n是一个局部变量，同state.count
// 失去响应性连接
let n = state.count
// 不影响原始的state
n++

// count也和state.count失去了响应性连接
let { count } = state
// 不会影响原始的state
count++

// 该函数接收一个普通数字，并且
// 将无法跟踪state.count 的变化
callSomeFunction(state.count)
```
#### readonly()
```
接受一个对象（不论是响应式还是普通的）或是一个ref，返回一个愿值的只读代理。
.类型
function readonly<T extends object>(
    target:T
):DeepReadonly<UnwrapNestedRefs<T>>
.详细信息
只读代理是深层的：对任何嵌套属性的访问都将是只读的。它的ref解包行为与
reactive()相同，但解包得到的值都是只读的。
要避免深层级的转换行为，请使用shallowReadonly()作替代。

.示例
const original = reactive({ count:0 })
const copy = readonly(original)

watchEffect(()=>{
    // 用来做响应性追踪
    console.log(copy.count)
})
// 更改源属性会触发其依赖的侦听器
original.count++
// 更改该只读副本将会失败，并得到一个警告
copy.count++ // warning!
```
#### watchEffect()
```
立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行；

.类型
function watchEffect(
    effect:(onCleanup:OnCleanup) => void,
    options?:WatchEffectOptions
):StopHandle
type OnCleanup = (CleanupFn:()=>void)=>void

interface WatchEffectOptions {
    flush?:'pre'|'post'|'sync' // 默认： ‘pre’
    onTrack?:(event:DebuggerEvent)=>void
    onTrigger?:(event:DebuggerEvent)=>void
}

type StopHandle = ()=> void

.详细信息
第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回
调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的
异步请求（参见下面的示例）
第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。

默认情况下，侦听器将在组件渲染之前执行。设置flush:'post'将会使侦听器延迟到组件渲染
之后再执行。详见回调的触发时机。在某些特殊情况下（例如要使缓存失效），可能有必要在响应式
依赖发生变化时立即触发侦听器。这可以通过设置flush:'sync'来实现。然而，该设置应谨慎使用，
因为如果有多个属性同时更新，这将导致一些性能和数据一致性的问题。

返回值是一个用来停止该副作用的函数。

.示例
const count = ref(0)
watchEffect(()=>cconsole.log(count.value))
// -> 输出 0
count.value++
// -> 输出 1

副作用清除：
watchEffect(async (onCleanup)=>{
    const { response,cancel } = doAsyncWork(id.value)
    // 'cancel' 会在 ‘id’ 更改时调用
    // 以便取消之前
    // 未完成的请求
    onCleanup(cancel)
    data.value = await response
})

停止侦听器
const stop = watchEffect(()=>{})
<!-- 当不再需要此侦听器时 -->
stop()

选项：
watchEffect(()=>{},{
    flush: 'post',
    onTrack(e){
      debugger
    },
    onTrigger(e){
      debugger  
    }
})
```
#### watchPostEffect()
```
watchEffect() 使用 flush: 'post' 选项时的别名。
```
#### watchSyncEffect()
```
watchEffect() 使用 flush: 'sync' 选项时的别名。
```
#### watch()
```
侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。
.类型
// 侦听单个来源
function watch<T>(
    source:WatchSource<T>,
    callback: WatchCallback<T>,
    options?: WatchOptions
): StopHandle

// 侦听多个来源
function watch<T>(
  sources: WatchSource<T>[],
  callback: WatchCallback<T[]>,
  options?: WatchOptions
): StopHandle

type WatchCallback<T> = (
  value: T,
  oldValue: T,
  onCleanup: (cleanupFn: () => void) => void
) => void

type WatchSource<T> =
  | Ref<T> // ref
  | (() => T) // getter
  | T extends object
  ? T
  : never // 响应式对象

interface WatchOptions extends WatchEffectOptions {
  immediate?: boolean // 默认：false
  deep?: boolean // 默认：false
  flush?: 'pre' | 'post' | 'sync' // 默认：'pre'
  onTrack?: (event: DebuggerEvent) => void
  onTrigger?: (event: DebuggerEvent) => void
}

为了便于阅读，对类型进行了简化。

.详细信息
watch()默认是懒侦听的，即仅在侦听源发生变化时才执行回调函数。
第一个参数是侦听器源。这个来源可以是以下几种：
一个函数，返回一个值
一个ref
一个响应式对象
... 或是有以上类型的值组成的数组

第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及
一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。

当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。
第三个可选的参数是一个对象，支持以下这些选项：
. immediate: 在侦听器创建时立即触发回调。第一次调用时，旧值将为undefined。
. deep: 如果源是对象或数组，则强制深度遍历源，以便在深度变更时触发回调。
. flush: 调整回调的刷新时机。
. onTrack/onTrigger: 调试侦听器的依赖关系。
声明侦听器回调时避免使用箭头函数，因为它们将无法通过this访问组件实例。
. 示例
export default {
    data(){
        return {
            a:1,
            b:2,
            c:{
                d:4
            },
            e:5,
            f:6
        }
    },
    watch: {
        // 侦听根级属性
        a(val,oldVal){
          console.log(`new: ${val},old:${oldVal}`)
        },
        // 字符串方法名称
        b: 'someMethod',
        // 该回调将会在被侦听的对象的属性改变时调动，无论其被嵌套多深
        c:{
            handler(val,oldVal){
                console.log('c changed')
            },
            deep:true
        },
        // 侦听单个嵌套属性：
        'c.d':function(val,oldVal){
            // do something
        },
        // 该回调将会在侦听开始之后立即调用
        e:{
            handler(val,oldVal){
                console.log('e changed')
            },
            immediate:true
        },
        // 你可以传入回调数组，它们将会被逐一调用
        f:[
          'handle1',
          function handle2(val,oldVal){
            console.log('handle2 triggered')
          },
          {
              handler:function handle3(val,oldVal){
                  console.log('handle3 triggered')
              }
          }
        ]
    },
    methods:{
        someMethod(){
          console.log('b changed')
        },
        handle1() {
            console.log('handle1 triggered')
        }
    },
    created(){
        this.a = 3 // => new: 3, old: 1
    }
}
```
#### emits
```
用于声明由组件触发的自定义事件。
.类型
interface ComponentOptions {
   emits?:ArrayEmitsOptions | ObjectEmitsOptions
}

type ArrayEmitsOptions = string[]

type ObjectEmitsOptions = { [key: string]: EmitValidator | null }

type EmitValidator = (...args: unknown[]) => boolean

.详细信息
可以以两种形式声明触发的事件：
. 使用字符串数组的简易形式。
. 使用对象的完整形式。该对象的每个属性键是事件的名称，值是null或一个验证函数。
验证函数会接收到传递给组件的$emit调用的额外参数。例如，如果
this.$emit('foo',1)被调用，foo相应的验证函数将接受参数1。验证函数应返回布尔值，
以表明事件参数是否通过了验证。

注意，emits选项会影响一个监听器被解析为组件事件监听器，还是还原DOM事件监听器。
被声明为组件事件的监听器不会被透传到组件的根元素上，且将从组件的$attrs对象中移除。
.示例
数组语法：
export default{
    emits:['check'],
    created() {
        this.$emit('check')
    }
}
对象语法：
export default{
    emits:{
        // 没有验证函数
        click: null,
        // 具有验证函数
        submit:(payload)=>{
            if(payload.email&&payload.password){
                return true
            }else {
                console.log.warn(`Invalid submit event payload`)
                return false
            }
        }
    }
}
```
#### expose
```
用于声明当组件实例被父组件通过模板引用访问时暴露的公共属性。
.类型
interface ComponentOptions {
    expose?:string[]
}
.详细信息
默认情况下，当通过$parent、$root或模板引用访问时，组件实例将向父组件暴露
所有的实例属性。这可能不是我们希望看到的，因为组件很可能拥有一些应保持私有的内部
状态或方法，以避免紧耦合。

expose选项值应当是一个包含要暴露的属性名称字符串的数组。当使用expose时，只有显式列出
的属性将在组件实例上暴露。

expose 仅影响用户定义的属性 -- 它不会过滤掉内置的组件实例属性。
. 示例
export default{
    // 只有'publicMethod'在公共实例上可用
    expose: ['publicMethod'],
    methods: {
      publicMethod() {
        // ...
      },
      privateMethod() {
        // ...
      }
  }
}
```


## 单文件组件
### <script setup>
单文件组件 <script setup>
```
<script setup>是在单文件组件（SFC）中使用组合式API的编译时语法糖。
当同时使用SFC与组合式API时该语法是默认推荐。相比于普通的<script>
语法，它具有更多优势：
. 更少的样板内容，更简洁的代码。
. 能够使用纯TypeScript声明props和自定义事件。
. 更好的运行时性能（其模板会被编译成同一作用域内的渲染函数，避免了渲染上下文
代理对象）。
. 更好的IDE类型推导性能（减少了语言服务器从代码中抽取类型的工作）。
```
#### 基本语法
```
要启用该语法，需要在<script> 代码块上添加 setup attribute：
<script setup>
console.log('hello script setup')
</script>

里面的代码会被编译成组件setup()函数的内容。这意味着与普通的<script>只
在组件被首次引入的时候执行一次不同，<script setup>中的代码会在每次组件
实例被创建的时候执行。

顶层的绑定会被暴露给模板
当使用<script setup>的时候，任何在<script setup>声明的顶层的绑定（包括变量、函数声明，
以及import导入的内容）都能在模板中直接使用：
<script setup>
// 变量
const msg = 'Hello!'
// 函数
function log(){
    console.log(msg)
}
</script>
<template>
  <button @click="log">{{ msg }}</button>
</template>
import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 methods 选项来暴露它：
<script setup>
import { capitalize } from './helpers'
</script>

<template>
  <div>{{ capitalize('hello') }}</div>
</template>
```
#### 响应式
```
响应式状态需要明确使用响应式API来创建。和setup()函数的返回值一样，ref在模板中使用
的时候会自动解包：
<script setup>
import {ref} from 'vue'
const count = ref(0)
</script>
<template>
  <button @click="count++">{{ count }}</button>
</template>
```
#### 使用组件
```
<script setup>
import MyComponent from './MyComponent.vue'
</script>
<template>
  <MyComponent />
</template>
这里 MyComponent 应当被理解为像是在引用一个变量。如果你使用过 JSX，此处的心智模型是
类似的。其 kebab-case 格式的 <my-component> 同样能在模板中使用——不过，我们强烈建
议使用 PascalCase 格式以保持一致性。同时这也有助于区分原生的自定义元素。

. 动态组件

由于组件是通过变量引用而不是基于字符串组件名注册的，在<script setup>中要使用动态
组件的时候，应该使用动态的 :is 来绑定：

<script setup>
import Foo from './Foo.vue'
import Bar from './Bar.vue'
</script>

<template>
  <component :is="Foo" />
  <component :is="someCondition ? Foo : Bar" />
</template>

请注意组件是如何在三元表达式中被当做变量使用的。

. 递归组件
一个单文件组件可以通过它的文件名被其自己所引用。例如：名为FooBar.vue的组件
可以在其模板中用<FooBar/>引用它自己。

请注意这种方式相比于导入的组件优先级更低。如果有具名的导入和组件自身推导的名字冲突了，
可以为导入的组件添加别名：
import { FooBar as FooBarChild } from './components'

. 命名空间组件
可以使用带.的组件标签，例如<Foo.Bar>来引用嵌套在对象属性中的组件。这在需要从单
个文件中导入多个组件的时候非常有用：
<script setup>
import * as Form from './form-components'
</script>

<template>
  <Form.Input>
    <Form.Label>label</Form.Label>
  </Form.Input>
</template>
```
#### 使用自定义指令
```
全局注册的自定义指令将正常工作。本地的自定义指令在
<script setup>中不需要显式注册，但他们必须遵循
vNameOfDirective这样的命名规范：
<script setup>
const vMyDirective = {
    beforeMount:(el)=>{
        // 在元素上做些操作
    }
}
</script>
<template>
  <h1 v-my-directive>This is a Heading</h1>
</template>
如果指令是从别处导入的，可以通过重命名来使其符合命名规范：
<script setup>
import { myDirective as vMyDirective} from './MyDirective.js'
</script>
```
#### defineProps() 和 defineEmits()
```
为了在声明props和emits选项时获得完整的类型推导支持，我们可以使用defineProps
和defineEmits API，它们将自动地在<script setup>中可用：
<script setup>
const props = defineProps({
    foo:String
})
const emit = defineEmits(['change','delete'])
// setup 代码
</script>

. defineProps和defineEmits都是只能在<script setup>中使用的编译器宏。
他们不需要导入，且会随着<script setup>的处理过程一同被编译掉。
. defineProps接收与props选项相同的值，defineEmits接收与emits选项
相同的值。
.defineProps 和 defineEmits 在选项传入后，会提供恰当的类型推导。
.传入到defineProps和defineEmits的选项会从setup中提升到模块的作用域。因此，
传入的选项不能引用在setup作用域中声明的局部变量。这样做会引起编译错误。但是，
他可以引用导入的绑定，因为它们也在模块作用域内。
```
#### defineExpose
```
使用<script setup>的组件是默认关闭的---即通过模板引用或者$parent链
获取到的组件的公开实例，不会暴露任何在<script setup>中声明的绑定。

可以通过defineExpose编译器宏来显式指定在<script setup>组件中要暴露出去
的属性：
<script setup>
import { ref } from 'vue'

const a = 1
const b = ref(2)

defineExpose({
  a,
  b
})
</script>
当父组件通过模板引用的方式获取到当前组件的实例，获取到的实例会像这样 { a: number, b: number } (ref 会和在普通实例中一样被自动解包)
```